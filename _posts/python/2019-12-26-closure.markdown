---
layout: single
permalink: /python/1
title: "closure 메모리 관리"
date: 2019-12-26
categories: python
author_profile: true
comment: true
---

다음 코드는 함수 안에서 다른 함수를 만들어서 반환한다. 이를 **closure**이라고 한다.

```python
>>> def make_closure():
...    num1 = 1
...    num2 = 2
...    def inner():
...        return "MAKE CLOSURE WITH %d and %d" % (num1, num2)
...    return inner
...
>>> clo = make_closure()
>>>
```

그런데 이상한 점이 있다. `num1`과 `num2`는 `make_closure()`의 스택 범위 안에 존재하다가 그 스택 범위를 벗어나면 사라진다. 그런데 반환된 `clo()`는 `num1`과 `num2`를 가지고 있어야 한다. 이미 `make_closure()`의 범위를 벗어낫음에도 말이다. 벗어난 스택 범위에 접근하는 것은 위험한 행동이다. 책을 보면 다음과 같이 말하고 있다.
> closure는 다른 함수에 의해 **동적**으로 생성된다.

```python
>>> make_closure()
>>> <function make_closure.<locals>.inner at 0x0102CC40>
>>> del make_closure()
>>> make_closure()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'make_closure' is not defined
>>> clo()
MAKE CLOSURE WITH 1 and 2
>>>
```

위의 코드를 보면 `make_closure()`가 삭제되어도 `clo()`는 남아있다는 것을 알 수 있다. 따라서 `make_closure()`함수가 새로운 함수 오브젝트 `clo()`를 힙에 만든다는 것은 알 수 있고, `make_closure()`스택 내에 있는 `num1`과 `num2`에 접근하는 것이 아니라 따로 만들어서 사용한다는 것을 알 수 있다.

그럼 힙에 저장된 새로운 오브젝트는 `num1`과 `num2`를 어떻게 관리할지 의문이 생겼다.

새로 생성된 `clo()` 오브젝트는 `inner()`와 같다고 할 수 있을까? 아니다.

새로 생성된 `clo()`는 inner()와 같은 동작을 하지만 `make_closure()`에서 필요한 변수들을 포함해 가져간다. 따라서 `clo()`함수는 다음과 같이 생겼을 것이다.
```python
def clo():
    num1 = 1
    num2 = 2
    return "MAKE CLOSURE WITH %d and %d" % (num1, num2)
```

엄청난 비밀이 숨겨져 있을 줄 알았는데 생각보다 심심하다.

중요한 점은 closure가 변수를 외부에서 참조하는 것이 아니라 직접 생성해서 사용하게 된다는 점이다.

틀린 점이 있으면 알려주길 바랍니다.

#### 참고한 링크
[http://www.trytoprogram.com/python-programming/python-closures/][python closure]

[python closure]: http://www.trytoprogram.com/python-programming/python-closures/